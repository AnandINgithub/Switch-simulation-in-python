Switch-simulation-in-python
===========================

Implement self-learning and forwarding of bridge/switch via programing simulation. Consider a network topology where a switch is connected some PCs and other switches. For our implementation, we will consider that each switch has only 8 ports. Each switch will be represented by one program (sw) and each PC will be represented by another program (pc). We will use UDP port numbers to represent the ethernet address of each PC. Thus each PC will be invoked as ./pc -s &lt;my src port> -d &lt;switch udp port> Here &lt;my src port> represents src mac address of PC and program will listen for incoming msgs on this UDP port. The &lt;switch UDP port> indicates to which switch this PC is connected. On invoking the program, it will ask for input in the following format: &lt;dst port>, &lt;msg data> When i/p is received, this PC will send this data to switch i.e. to process listening on &lt;switch udp port>. Similarly, the switch program will be invoked as follows: ./sw -s &lt;my port>, -p &lt;port-1>, ..., &lt;port-N> The interpretation of these params are as follows: &lt;my port> is the udp port on which a switch will listen to receive msg from connected devices. &lt;port-1>, ..., &lt;port-N> are ports which implies that devices are connected i.e. those devices having these ethernet addresses (devices listening on these UDP ports> Whenever a switch receives a packet, the packet format will be &lt;dst port>,&lt;src port>, &lt;msg data>. From the src port, switch will learn that a device with this mac (i.e. port) is connected to it and active. Switch will build its Mac table (i.e. self learning table) with this address. If the &lt;dst-port> is in the Mac table, it will simply forward this message to that particular process. If the &lt;dst-port> is not in the Mac table, it will send the packet to all the connected devices (as specified by -p option). Each time switch learns a new address (port) it should dump i.e. print the current Mac table contents.
